const express = require('express');
const router = express.Router();
const crypto = require('crypto');

const USE_SQLITE = process.env.USE_SQLITE === 'true';
const Payment = USE_SQLITE ? require('../models/Payment-sqlite') : require('../models/Payment');
const Subscription = USE_SQLITE ? require('../models/Subscription-sqlite') : require('../models/Subscription');
const { authenticateToken } = require('../middleware/auth');

// è™çš®æ¤’é…ç½®æ£€æŸ¥
console.log('ğŸ” æ£€æŸ¥è™çš®æ¤’é…ç½®...');
console.log('XUNHU_APPID:', process.env.XUNHU_APPID ? 'å·²è®¾ç½®' : 'æœªè®¾ç½®');
console.log('XUNHU_APPSECRET:', process.env.XUNHU_APPSECRET ? 'å·²è®¾ç½®' : 'æœªè®¾ç½®');

// ç”Ÿæˆè™çš®æ¤’ç­¾å
function generateSign(params, secret) {
    const sortedKeys = Object.keys(params).sort();
    const signStr = sortedKeys.map(key => `${key}=${params[key]}`).join('&') + secret;
    return crypto.createHash('md5').update(signStr).digest('hex');
}

// åˆ›å»ºæ”¯ä»˜è®¢å•
router.post('/create', authenticateToken, async (req, res) => {
    try {
        const { planType } = req.body;
        const userId = req.user.id;

        if (!process.env.XUNHU_APPID || !process.env.XUNHU_APPSECRET) {
            return res.status(503).json({ success: false, error: 'æ”¯ä»˜åŠŸèƒ½æš‚æœªé…ç½®' });
        }

        if (!['monthly', 'yearly'].includes(planType)) {
            return res.status(400).json({ error: 'æ— æ•ˆçš„å¥—é¤ç±»å‹' });
        }

        const price = planType === 'monthly' ? 29 : 299;
        const tradeNo = 'RD' + Date.now() + Math.floor(Math.random() * 1000);

        const startDate = new Date();
        const endDate = new Date(startDate);
        endDate.setDate(endDate.getDate() + (planType === 'monthly' ? 30 : 365));

        // ä¸é¢„å…ˆåˆ›å»ºè®¢é˜…ï¼Œè€Œæ˜¯åˆ›å»ºæ”¯ä»˜è®°å½•ï¼Œç­‰å¾…å›è°ƒæˆåŠŸåå†å¤„ç†è®¢é˜…
        await Payment.create(userId, planType, null, price, tradeNo);

        // æ„å»ºè™çš®æ¤’æ”¯ä»˜å‚æ•°
        const payParams = {
            version: '1.1',
            appid: process.env.XUNHU_APPID,
            trade_order_id: tradeNo,
            total_fee: price.toFixed(2),
            title: 'ç¿å®AI - ' + (planType === 'monthly' ? 'æœˆåº¦' : 'å¹´åº¦') + 'è®¢é˜…',
            time: Math.floor(Date.now() / 1000).toString(),
            notify_url: process.env.XUNHU_NOTIFY_URL,
            return_url: process.env.XUNHU_RETURN_URL,
            nonce_str: Math.random().toString(36).substr(2, 15),
            type: 'wechat', // å¾®ä¿¡æ”¯ä»˜
            wap_name: 'ç¿å®AI'
        };

        // ç”Ÿæˆç­¾å
        payParams.hash = generateSign(payParams, process.env.XUNHU_APPSECRET);

// æ„å»ºæ”¯ä»˜URL
const payUrl = process.env.XUNHU_GATEWAY + '?' + 
    Object.keys(payParams).map(k => `${k}=${encodeURIComponent(payParams[k])}`).join('&');

console.log('âœ… åˆ›å»ºæ”¯ä»˜è®¢å•:', tradeNo);

// è¯·æ±‚æ”¯ä»˜ç½‘å…³è·å–æ”¯ä»˜é¡µé¢URL
try {
    const response = await fetch(payUrl);
    const result = await response.json();
    
    if (result.errcode === 0 && result.url) {
        // è¿”å›æ”¯ä»˜é¡µé¢URL
        res.json({ 
            success: true, 
            orderId: tradeNo, 
            paymentUrl: result.url,
            planType: planType, 
            amount: price 
        });
    } else {
        throw new Error('æ”¯ä»˜ç½‘å…³è¿”å›é”™è¯¯: ' + result.errmsg);
    }
} catch (fetchError) {
    console.error('è¯·æ±‚æ”¯ä»˜ç½‘å…³å¤±è´¥:', fetchError);
    res.status(500).json({ success: false, error: 'åˆ›å»ºæ”¯ä»˜å¤±è´¥', details: fetchError.message });
}

    } catch (error) {
        console.error('åˆ›å»ºæ”¯ä»˜è®¢å•å¤±è´¥:', error);
        res.status(500).json({ success: false, error: 'åˆ›å»ºæ”¯ä»˜è®¢å•å¤±è´¥', details: error.message });
    }
});

// æ”¯ä»˜å›è°ƒé€šçŸ¥
router.post('/notify', async (req, res) => {
    try {
        console.log('ğŸ“¥ æ”¶åˆ°è™çš®æ¤’å›è°ƒ:', req.body);
        
        const data = { ...req.body };
        const hash = data.hash;
        delete data.hash;

        // éªŒè¯ç­¾å
        const expectedHash = generateSign(data, process.env.XUNHU_APPSECRET);
        if (hash !== expectedHash) {
            console.error('âŒ ç­¾åéªŒè¯å¤±è´¥');
            return res.send('fail');
        }



        res.send('success');
    } catch (error) {
        console.error('âŒ å¤„ç†å›è°ƒå¤±è´¥:', error);
        res.send('fail');
    }
});

// åŒæ­¥è¿”å›
router.get('/return', async (req, res) => {
    try {
        const data = { ...req.query };
        const hash = data.hash;
        delete data.hash;

        const expectedHash = generateSign(data, process.env.XUNHU_APPSECRET);
        if (hash === expectedHash && data.trade_order_id) {
            return res.redirect(`http://ruiding.online/subscription.html?status=success&orderId=${data.trade_order_id}`);
        }
        res.redirect('http://ruiding.online/subscription.html?status=fail');
    } catch (error) {
        res.redirect('http://ruiding.online/subscription.html?status=error');
    }
});

// æŸ¥è¯¢è®¢å•çŠ¶æ€
router.get('/status/:orderId', authenticateToken, async (req, res) => {
    try {
        const payment = await Payment.findByTradeNo(req.params.orderId);
        if (!payment) return res.status(404).json({ error: 'è®¢å•ä¸å­˜åœ¨' });
        res.json({ 
            orderId: payment.trade_no, 
            status: payment.status, 
            amount: payment.amount, 
            createdAt: payment.created_at 
        });
    } catch (error) {
        res.status(500).json({ error: 'æŸ¥è¯¢å¤±è´¥' });
    }
});

// æ”¯ä»˜å†å²
router.get('/history', authenticateToken, async (req, res) => {
    try {
        const history = await Payment.findByUserId(req.user.id);
        res.json({ 
            success: true, 
            history: history.map(p => ({ 
                orderId: p.trade_no, 
                amount: p.amount, 
                status: p.status, 
                paymentMethod: p.payment_method, 
                planType: p.plan_type, 
                createdAt: p.created_at 
            })) 
        });
    } catch (error) {
        res.status(500).json({ error: 'è·å–å†å²å¤±è´¥' });
    }
});

module.exports = router;
